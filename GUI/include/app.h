/**
 * Application class declaration for a GameBoy color emulator. This class acts
 * as the parent WxWidget application.
 */
#ifndef APP_H
#define APP_H

#include <wx/wxprec.h>
#include "wx/thread.h"
#include "wx/dynarray.h"
#include "wx/numdlg.h"
#include "wx/progdlg.h"
#include "wx/grid.h"
#include <string>

// Forward declarations.
class EmulationThread;
class MainWindowFrame;
class CPUStateFrame;
class Core;
class MemoryViewerFrame;
class PaletteViewerFrame;
class TileViewerFrame;
class OAMViewerFrame;
class BackgroundViewerFrame;
class CartridgeViewerFrame;
class BreakpointManagerFrame;

// An Enum defining the wxIDs used for each of the custom menu bar actions.
enum wxMenuIDs {
	OPEN_CPU_STATE_VIEW = 1,
	OPEN_MEMORY_VIEWER_VIEW,
	OPEN_PALETTE_VIEWER_VIEW,
	OPEN_TILE_VIEWER_VIEW,
	OPEN_OAM_VIEWER_VIEW,
	OPEN_BACKGROUND_VIEWER_VIEW,
	OPEN_CARTRIDGE_VIEWER_VIEW,
	MEMORY_MAP_SEARCHBAR,
	PAUSE_EMULATION_MENU,
	CONTINUE_EMULATION_MENU,
	STEP_FRAME_MENU,
	STEP_CPU_MENU,
	OPEN_BREAKPOINT_MANAGER,
	DISPLAY_SIZE_1,
	DISPLAY_SIZE_2,
	DISPLAY_SIZE_3,
	DISPLAY_SIZE_4,
	DISPLAY_SIZE_5,
	OPEN_ROM,
	CLOSE_ROM,
	RESET_GAMEBOY
};

const char APP_TITLE[] = "RedPandaEmu";
#define MAIN_WINDOW_WIDTH 160
#define MAIN_WINDOW_HEIGHT 144
#define MAIN_WINDOW_DISPLAY_PIXEL_DEPTH 24

const char CPU_STATE_DISPLAY_TITLE[] = "CPU State";
#define CPU_STATE_DISPLAY_WIDTH 300
#define CPU_STATE_DISPLAY_HEIGHT 355

const char MEMORY_VIEWER_DISPLAY_TITLE[] = "Memory Viewer";
#define MEMORY_VIEWER_DISPLAY_WIDTH 700
#define MEMORY_VIEWER_DISPLAY_HEIGHT 500

const char PALETTE_VIEWER_DISPLAY_TITLE[] = "Palette Viewer";
const char TILE_VIEWER_DISPLAY_TITLE[] = "Tile Viewer";
const char OAM_VIEWER_DISPLAY_TITLE[] = "Object Attribute Memory Viewer";
const char BACKGROUND_VIEWER_DISPLAY_TITLE[] = "Background Map Viewer";
const char CARTRIDGE_VIEWER_DISPLAY_TITLE[] = "Cartridge Info";

const char BREAKPOINT_MANAGER_TITLE[] = "Breakpoints";

// The parent WxWidget application.
class App : public wxApp
{
public:
	virtual bool OnInit();
	virtual int OnExit();

	/**
	 * @brief Gets the current running state of the emulation core.	
	 * 
	 * @return Returns a boolean indicating whether or not the emulator
	 * is currently running.
	 */
	bool getRunningEmulationState() { return runningEmulator; }
	/**
	 * @brief Sets the current running state of the emulation core.
	 * 
	 * @param state The running state to set the emulation core to.
	 */
	void setRunningEmulationState(bool state) { runningEmulator = state; }

	/**
     * @brief Loads a ROM file and begins emulation.
     * On failure, the application is exited.
     * 
     * @param filePath The absolute path to the ROM file.
     */
	void loadCartridge(std::string filepath);

	/**
	 * @brief Initialize the SDL2 subsystem.
	 * 
	 * Will output error messages to std::cerr upon failure.
	 * 
	 * @return Returns the success of SDL's initialization.
	 */
	bool initializeSDL2();

	/**
	 * @brief Closes all frames except the main emulator frame.
	 */
	void closeAllSideFrames();

	/**
	 * @brief Reveals the CPU state frame.
	 */
	void showCPUStateFrame();

	/**
	 * @brief Reveals the memory viewer frame.
	 */
	void showMemoryViewerFrame();

	/**
	 * @brief Reveals the palette viewer frame.
	 */
	void showPaletteViewerFrame();

	/**
	 * @brief Reveals the tile viewer frame.
	 */
	void showTileViewerFrame();

	/**
	 * @brief Reveals the OAM viewer frame.
	 */
	void showOAMViewerFrame();

	/**
	 * @brief Reveals the background viewer frame.
	 */
	void showBackgroundViewerFrame();

	/**
	 * @brief Reveals the cartridge viewer frame.
	 */
	void showCartridgeViewerFrame();

	/**
	 * @brief Reveals the breakpoint manager frame.
	 */
	void showBreakpointManagerFrame();

	/**
	 * @brief Returns the currently loaded ROM file.
	 */
	std::string getCurrentlyLoadedFilePath(){ return currentlyLoadedFilePath;}

	/**
	 * @brief Clears the currently loaded ROM file.
	 */
	void clearCurrentlyLoadedFilePath();

	/**
	 * @brief Sends an 'EMULATOR_CORE_UPDATE_EVENT' to the rest of the application. This 
	 * event should be generated by the emulator core when it wishes the rest of the GUI
	 * to update.
	 */
	void sendEmulationCoreUpdateEvent();
	/**
	 * @brief Sends an 'ON_CARTRIDGE_LOADED_EVENT' to the rest of the application. This 
	 * event should be generated by the emulator core when it successfully loads a new 
	 * cartridge.
	 */
	void sendCartridgeLoadedEvent();

private:
	// A boolean indicating whether the emulator is currently running.
	bool runningEmulator = true;

	std::string currentlyLoadedFilePath = "";

	EmulationThread *emuThread = nullptr;
	
	MainWindowFrame *mainWindow = nullptr;
	CPUStateFrame *cpuStateFrame = nullptr;
	MemoryViewerFrame *memoryViewerFrame = nullptr;
	PaletteViewerFrame *paletteViewerFrame = nullptr;
	TileViewerFrame *tileViewerFrame = nullptr;
	OAMViewerFrame *oamViewerFrame = nullptr;
	BackgroundViewerFrame *backgroundViewerFrame = nullptr;
	CartridgeViewerFrame *cartridgeViewerFrame = nullptr;
	BreakpointManagerFrame *breakpointManagerFrame = nullptr;

	Core *emuCore = nullptr;
};

#endif